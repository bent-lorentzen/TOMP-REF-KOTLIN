/**
 * NOTE: This class is auto generated by the swagger code generator program (3.0.30).
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */
package io.swagger.api

import io.swagger.model.Error
import io.swagger.model.ExtraCosts
import io.swagger.model.JournalEntry
import io.swagger.model.JournalState
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.enums.ParameterIn
import io.swagger.v3.oas.annotations.media.ArraySchema
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.security.SecurityRequirement
import org.springframework.http.ResponseEntity
import org.springframework.validation.annotation.Validated
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestMethod
import org.springframework.web.bind.annotation.RequestParam
import org.threeten.bp.OffsetDateTime
import javax.annotation.Generated
import javax.validation.Valid
import javax.validation.constraints.Min

@Generated(value = ["io.swagger.codegen.v3.generators.java.SpringCodegen"], date = "2021-12-10T11:36:21.130Z[GMT]")
@Validated
interface PaymentApi {
    @Operation(
        summary = "",
        description = "extra costs that the TO has to charge to the MP or vice versa.",
        security = [SecurityRequirement(name = "ApiKeyAuth"), SecurityRequirement(name = "BasicAuth"), SecurityRequirement(name = "BearerAuth"), SecurityRequirement(
            name = "OAuth",
            scopes = []
        ), SecurityRequirement(name = "OpenId")],
        tags = ["payment", "MP"]
    )
    @ApiResponses(
        value = [ApiResponse(
            responseCode = "200",
            description = "journal entry received, will be processed (state = INVOICED)",
            content = Content(mediaType = "application/json", schema = Schema(implementation = JournalEntry::class))
        ), ApiResponse(
            responseCode = "400",
            description = "Bad request. See https://github.com/TOMP-WG/TOMP-API/wiki/Error-handling-in-TOMP for further explanation of error code.",
            content = Content(mediaType = "application/json", schema = Schema(implementation = Error::class))
        ), ApiResponse(
            responseCode = "401",
            description = "Although the HTTP standard specifies \"unauthorized\", semantically this response means \"unauthenticated\". That is, the client must authenticate itself to get the requested response.",
            content = Content(mediaType = "application/json", schema = Schema(implementation = Error::class))
        ), ApiResponse(
            responseCode = "403",
            description = "The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.",
            content = Content(mediaType = "application/json", schema = Schema(implementation = Error::class))
        )]
    )
    @RequestMapping(
        value = ["/payment/{id}/claim-extra-costs"],
        produces = ["application/json"],
        consumes = ["application/json"],
        method = [RequestMethod.POST]
    )
    fun paymentIdClaimExtraCostsPost(
        @Parameter(
            `in` = ParameterIn.HEADER,
            description = "A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information",
            required = true,
            schema = Schema
        ) @RequestHeader(value = "Accept-Language", required = true) acceptLanguage: String?,
        @Parameter(
            `in` = ParameterIn.HEADER,
            description = "API description, can be TOMP or maybe other (specific/derived) API definitions",
            required = true,
            schema = Schema
        ) @RequestHeader(value = "Api", required = true) api: String?,
        @Parameter(
            `in` = ParameterIn.HEADER,
            description = "Version of the API.",
            required = true,
            schema = Schema
        ) @RequestHeader(value = "Api-Version", required = true) apiVersion: String?,
        @Parameter(`in` = ParameterIn.HEADER, description = "The ID of the sending maas operator", required = true, schema = Schema) @RequestHeader(
            value = "maas-id",
            required = true
        ) maasId: String?,
        @Parameter(`in` = ParameterIn.PATH, description = "Booking identifier", required = true, schema = Schema) @PathVariable("id") id: String?,
        @Parameter(
            `in` = ParameterIn.HEADER,
            description = "The ID of the maas operator that has to receive this message",
            schema = Schema
        ) @RequestHeader(value = "addressed-to", required = false) addressedTo: String?,
        @Parameter(`in` = ParameterIn.DEFAULT, description = "", schema = Schema) @RequestBody body: @Valid ExtraCosts?
    ): ResponseEntity<JournalEntry?>

    @Operation(
        summary = "",
        description = "Returns all the journal entries that should be paid per leg",
        security = [SecurityRequirement(name = "ApiKeyAuth"), SecurityRequirement(name = "BasicAuth"), SecurityRequirement(name = "BearerAuth"), SecurityRequirement(
            name = "OAuth",
            scopes = []
        ), SecurityRequirement(name = "OpenId")],
        tags = ["payment", "MP", "TO"]
    )
    @ApiResponses(
        value = [ApiResponse(
            responseCode = "200",
            description = "journal entries",
            content = Content(mediaType = "application/json", array = ArraySchema(schema = Schema(implementation = JournalEntry::class)))
        ), ApiResponse(
            responseCode = "400",
            description = "Bad request. See https://github.com/TOMP-WG/TOMP-API/wiki/Error-handling-in-TOMP for further explanation of error code.",
            content = Content(mediaType = "application/json", schema = Schema(implementation = Error::class))
        ), ApiResponse(
            responseCode = "401",
            description = "Although the HTTP standard specifies \"unauthorized\", semantically this response means \"unauthenticated\". That is, the client must authenticate itself to get the requested response.",
            content = Content(mediaType = "application/json", schema = Schema(implementation = Error::class))
        ), ApiResponse(
            responseCode = "403",
            description = "The client does not have access rights to the content, i.e. they are unauthorized, so server is rejecting to give proper response. Unlike 401, the client's identity is known to the server.",
            content = Content(mediaType = "application/json", schema = Schema(implementation = Error::class))
        )]
    )
    @RequestMapping(value = ["/payment/journal-entry"], produces = ["application/json"], method = [RequestMethod.GET])
    fun paymentJournalEntryGet(
        @Parameter(
            `in` = ParameterIn.HEADER,
            description = "A list of the languages/localizations the user would like to see the results in. For user privacy and ease of use on the TO side, this list should be kept as short as possible, ideally just one language tag from the list in operator/information",
            required = true,
            schema = Schema
        ) @RequestHeader(value = "Accept-Language", required = true) acceptLanguage: String?,
        @Parameter(
            `in` = ParameterIn.HEADER,
            description = "API description, can be TOMP or maybe other (specific/derived) API definitions",
            required = true,
            schema = Schema
        ) @RequestHeader(value = "Api", required = true) api: String?,
        @Parameter(
            `in` = ParameterIn.HEADER,
            description = "Version of the API.",
            required = true,
            schema = Schema
        ) @RequestHeader(value = "Api-Version", required = true) apiVersion: String?,
        @Parameter(`in` = ParameterIn.HEADER, description = "The ID of the sending maas operator", required = true, schema = Schema) @RequestHeader(
            value = "maas-id",
            required = true
        ) maasId: String?,
        @Parameter(
            `in` = ParameterIn.HEADER,
            description = "The ID of the maas operator that has to receive this message",
            schema = Schema
        ) @RequestHeader(value = "addressed-to", required = false) addressedTo: String?,
        @Parameter(`in` = ParameterIn.QUERY, description = "start of the selection", schema = Schema) @RequestParam(
            value = "from",
            required = false
        ) from: @Valid OffsetDateTime?,
        @Parameter(`in` = ParameterIn.QUERY, description = "end of the selection", schema = Schema) @RequestParam(
            value = "to",
            required = false
        ) to: @Valid OffsetDateTime?,
        @Parameter(`in` = ParameterIn.QUERY, description = "", schema = Schema) @RequestParam(
            value = "state",
            required = false
        ) state: @Valid JournalState?,
        @Parameter(`in` = ParameterIn.QUERY, description = "", schema = Schema) @RequestParam(value = "id", required = false) id: @Valid String?,
        @Parameter(
            `in` = ParameterIn.QUERY,
            description = "type of booking line (e.g. fare, addition costs, fines, ...)",
            schema = Schema(allowableValues = ["ALL", "DAMAGE", "LOSS", "STOLEN", "EXTRA_USAGE", "REFUND", "FINE", "OTHER_ASSET_USED", "CREDIT", "VOUCHER", "DEPOSIT", "OTHER"])
        ) @RequestParam(value = "category", required = false) category: @Valid String?,
        @Parameter(
            `in` = ParameterIn.QUERY,
            description = "start of the selection",
            schema = Schema(allowableValues = [], defaultValue = "0")
        ) @RequestParam(value = "offset", required = false, defaultValue = "0") offset: @Min(0) @Valid Int?,
        @Parameter(
            `in` = ParameterIn.QUERY,
            description = "count of the selection",
            schema = Schema(allowableValues = [])
        ) @RequestParam(value = "limit", required = false) limit: @Min(0) @Valid Int?
    ): ResponseEntity<List<JournalEntry?>?>
}
